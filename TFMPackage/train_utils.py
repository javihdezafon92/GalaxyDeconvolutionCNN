"""
In this file we collect the set of functions used for the training and evaluation of the models.
"""


import os
from datetime import date
import numpy as np
import math
from TFMPackage import plot_utils
import sklearn as sk
from skimage.metrics import structural_similarity as ssim
from tensorflow import keras
from tensorflow.keras import layers
from keras.layers import Add
from tensorflow.python.framework import ops
from tensorflow.keras.models import Model

import cv2

def preprocess(array, dim=1, max_value=255):
    """
    Normalizes the supplied array and reshapes it into the appropriate format.
    
    :param ndarray array: array of image dataset
    :param int dim: number of color channels
    :param int max_value: maximum value of intensity of normalized images
    :return ndarray array: a normalizaed array of the images dataset
    """

    array = array.astype("float32") / max_value
    array = np.reshape(array, (len(array), 64, 64, dim))
    return array

def create_directory(problem_type, noise_level):
    '''
    This function creates a directory to safe a model and its history after trainning
    
    :param str problem_type: distinguish the denoising problem from the full deconvolution problem for the directory name
    :param str noise_level: indicates the noise level of the images dataset processed for the directory name
    :return str save_dir: the name of the directory    
    '''
    current_dir=os.getcwd()
    today = date.today()
    current_date = today.strftime("%m%d%Y")
    save_dir = current_dir + "\\train_" + current_date +  "\\"+ problem_type + "\\" + noise_level
    
    # Check whether the specified path exists or not
    isExist = os.path.exists(save_dir)

    if not isExist:
  
      # Create a new directory because it does not exist 
      os.makedirs(save_dir)
        
    return save_dir

def create_directory_images(problem_type):
    '''
    This function creates a directory to safe the .fits files generated by the get_fits function of the plot_utils module of TFMPackage
    
    :param str problem_type: distinguish the denoising problem from the full deconvolution problem for the directory name
    :return str save_dir: the name of the directory
    '''
    current_dir=os.getcwd()
    today = date.today()
    current_date = today.strftime("%m%d%Y")
    save_dir = current_dir + "\\images_" + current_date +  "\\"+ problem_type
    
    # Check whether the specified path exists or not
    isExist = os.path.exists(save_dir)

    if not isExist:
  
      # Create a new directory because it does not exist 
      os.makedirs(save_dir)
        
    return save_dir

def train_model(model, X_train, y_train, X_val, y_val, model_save_path, history_save_path, input_shape = (64, 64, 1),
                optimizer="rmsprop", epochs = 40, batch_size = 128, loss="mse"):
    '''
    This function trains and save an object model and its history
    
    :param keras.engine.functional.Functional model: a keras model
    :param ndarray X_train: the input trainning dataset
    :param ndarray Y_train: the output trainning dataset
    :param ndarray X_val: the input validation dataset
    :param ndarray Y_val: the output validation dataset
    :param str model_save_path: the path to save the trainned model
    :param str history_save_path: the path to save the history of the trainned model
    :param tuple input_shape: shape of the input images
    :param str optimizer: the optimization algorithm chosen for model trainning
    :param int epochs: number of epochs to train the model
    :param int batch_size: number of samples per gradient update
    :param str loss: loss function
    :return keras.engine.functional.Functional model: the trainned model
    :return keras.callbacks.History history: the history of the trainned model
    '''
    #Compile
    model.compile(optimizer = optimizer, loss = loss)
    
    #Train
    history = model.fit(
    x = X_train,
    y = y_train,
    epochs = epochs,
    batch_size = batch_size,
    shuffle = True,
    validation_data = (X_val, y_val),
    )
    
    #Save model
    np.save(history_save_path, history.history)
    model.save(model_save_path)
    
    return model, history


def obtain_PSNR(MSE, bits):
    '''
    This function returns de average PSNR (peak signal to noise ratio) between the images of a reference images set and a processed images set
    :param float MSE: average MSE (mean squared error) between the reference images and the processed
    :param int bits: number of bits of the images
    :return float PSNR: average PSNR 
    '''
    r = 2**bits-1
    PSNR = 20 * np.log10(r / math.sqrt(MSE))
    
    return PSNR

def obtain_SSIM(X, y):
    '''
    This function returns de average SSIM (structural similarity) between the images of a reference images set and a processed images set
    
    :param ndarray X: processed images
    :param ndarray y: reference images
    :return float SSIM_mean: average SSIM
    '''
    SSIM_List = []
    for i in range(len(X)):
        img1 = y[i,:,:,0]
        img2 = X[i,:,:,0]
        SSIM_List.append(ssim(img1, img2, data_range=img1.max() - img1.min()))
    
    SSIM_mean = np.mean(SSIM_List)
    return SSIM_mean

def obtain_MSE(X, y, bits = 16):
    '''
    This function returns de average MSE (mean squared error) between the images of a reference images set and a processed images set
    
    :param ndarray X: processed images
    :param ndarray y: reference images
    :return float MSE_mean: average MSE
    
    '''
    MSE_List = []
    cod_type = 'uint' + str(bits)
    r = 2**bits-1
    
    for i in range(len(X)):        
        image1 = (X[i,:,:,0]*r).astype(cod_type)        
        image2 = (y[i,:,:,0]*r).astype(cod_type)        
        MSE_List.append(np.mean((image1.astype(np.float64) - image2.astype(np.float64)) ** 2))             
        
    MSE_mean = np.mean(MSE_List)    
    return MSE_mean


def test_model(model, X_test, y_test, n = 10, bits = 16, plot_examples = True):
    
    '''
    This function compares the predicted images by the trainned model with the reference images and the ones with aberrations, and show gain in MSE, PSNR and SSIM.
    
    :param keras.engine.functional.Functional model: the trainned model
    :param ndarray X_test: images with aberrations
    :param ndarray y_test: reference images
    :param int n: number of images to compare
    :param int bits: number of bits of the images
    :param bool plot_examples: true if want to plot a comparison of noised/convolved images and predicted images with the reference images    
    
    '''
    
    predictions = model.predict(X_test) #Getting prediction with trainned model    
    
    if plot_examples == True:
        #Comparing with noised images
        print('\nNoised images vs predictions\n')
        plot_utils.display(X_test, predictions, n)
    
    if plot_examples == True:
        #Comparing with original iamges
        print('\nOriginal images vs predictions\n')
        plot_utils.display(y_test, predictions, n)
    
    #MSE comparison
    MSE_prev = obtain_MSE(X_test, y_test)
    print('\nAverage MSE between reference and with aberrations images: ', MSE_prev)

    MSE_pred = obtain_MSE(predictions, y_test)
    print('\nAverage MSE between reference and corrected images: ', MSE_pred)
    
    #PSNR Gain
    PSNR_prev = obtain_PSNR(MSE_prev, bits = 16) 
    print('\nAverage PSNR between reference and with aberrations images: ', PSNR_prev)

    PSNR_pred = obtain_PSNR(MSE_pred, bits = 16)
    print('\nAverage PSNR between reference and corrected images: ', PSNR_pred)
    
    #SSIM comparison
    SSIM_prev = obtain_SSIM(X_test, y_test) 
    print('\nAverage SSIM between reference and with aberrations images: ', SSIM_prev)

    SSIM_pred = obtain_SSIM(predictions, y_test)
    print('\nAverage SSIM between reference and corrected images: ', SSIM_pred)
       
    #return MSE_prev, MSE_pred, PSNR_prev, PSNR_pred